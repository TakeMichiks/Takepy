import json
from flask import Flask, jsonify, request
from flask_marshmallow import Marshmallow
from marshmallow import fields, ValidationError

# =================================================================
# 1. CONFIGURACIÓN INICIAL Y PREPARACIÓN DE LA APP
# =================================================================
app = Flask(__name__)
ma = Marshmallow(app)
DB_FILE = "libros.json"  # Nombre del archivo que funcionará como nuestra base de datos

# =================================================================
# 2. FUNCIONES AUXILIARES PARA MANEJAR LA "BASE DE DATOS" (el archivo JSON)
# =================================================================

def leer_db():
    """
    Lee y devuelve todos los datos del archivo libros.json.
    Si el archivo no existe o está corrupto, devuelve una lista vacía.
    """
    try:
        with open(DB_FILE, "r") as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        return []

def escribir_db(data):
    """
    Recibe datos (una lista de diccionarios) y los escribe en el archivo libros.json.
    Sobrescribe el contenido anterior. `indent=4` formatea el JSON para que sea legible.
    """
    with open(DB_FILE, "w") as f:
        json.dump(data, f, indent=4)

# =================================================================
# 3. DEFINICIÓN DEL SCHEMA (SERIALIZER CON MARSHMALLOW)
# =================================================================

class LibroSchema(ma.Schema):
    """
    Este es el "serializer". Define la estructura de nuestros datos para la API.
    Controla tanto la entrada (deserialización) como la salida (serialización).
    """
    # dump_only=True: Este campo se usa solo para la SALIDA (serialización).
    # Se ignora cuando se leen datos de entrada (en un POST).
    # Esto es crucial para que el cliente no pueda asignar su propio ID.
    id = fields.Int(dump_only=True)

    # required=True: Este campo es OBLIGATORIO en la ENTRADA (deserialización).
    # Si no se proporciona en el JSON de un POST, Marshmallow dará un error de validación.
    titulo = fields.Str(required=True, error_messages={"required": "El título es obligatorio."})
    autor = fields.Str(required=True, error_messages={"required": "El autor es obligatorio."})

    class Meta:
        # Define el orden de los campos en la salida JSON.
        fields = ("id", "titulo", "autor")

# --- Instanciación de los Schemas ---
libro_schema = LibroSchema()  # Para manejar un solo libro.
libros_schema = LibroSchema(many=True)  # Para manejar una lista de libros.

# =================================================================
# 4. DEFINICIÓN DE LOS ENDPOINTS (RUTAS DE LA API)
# =================================================================

@app.route("/api/libros", methods=["GET", "POST"])
def manejar_libros():
    """
    Esta función maneja las dos operaciones para el endpoint /api/libros:
    - GET: Devuelve la lista de todos los libros.
    - POST: Crea un nuevo libro.
    """

    # -----------------------------------------------------------------
    # LÓGICA PARA EL MÉTODO GET (SERIALIZACIÓN)
    # -----------------------------------------------------------------
    if request.method == "GET":
        # 1. Obtener los datos: Leemos todos los libros de nuestro archivo JSON.
        #    'libros' es una lista de diccionarios de Python.
        libros = leer_db()

        # 2. Serializar los datos: Convertimos la lista de objetos Python a formato JSON.
        #    'libros_schema' (con many=True) se encarga de procesar cada diccionario
        #    de la lista y aplicar la estructura definida en LibroSchema.
        #    .jsonify() crea la respuesta HTTP con el Content-Type correcto (application/json).
        return libros_schema.jsonify(libros)

    # -----------------------------------------------------------------
    # LÓGICA PARA EL MÉTODO POST (DESERIALIZACIÓN Y VALIDACIÓN)
    # -----------------------------------------------------------------
    if request.method == "POST":
        # 1. Obtener los datos de entrada: `request.get_json()` parsea el cuerpo de la
        #    petición JSON y lo convierte en un diccionario de Python.
        json_data = request.get_json()
        if not json_data:
            return jsonify({"error": "No se enviaron datos en la petición."}), 400

        try:
            # 2. Validar y Deserializar: `libro_schema.load(json_data)` es el paso clave.
            #    - VALIDA que `json_data` contenga los campos 'titulo' y 'autor' (porque son `required=True`).
            #    - DESERIALIZA los datos, es decir, los convierte en un diccionario Python limpio
            #      y estructurado según el schema.
            #    - Ignora el campo 'id' si viniera en la petición (porque es `dump_only`).
            datos_libro = libro_schema.load(json_data)

        except ValidationError as err:
            # 3. Manejo de errores de validación: Si `.load()` falla, se captura la excepción.
            #    `err.messages` contiene un diccionario con los errores detallados.
            #    Devolvemos estos errores al cliente con un código 422.
            return jsonify(err.messages), 422

        # 4. Procesar y guardar los datos validados:
        libros = leer_db()  # Leemos la lista actual de libros.
        
        nuevo_id = libros[-1]["id"] + 1 if libros else 1 # Calculamos un nuevo ID.
        datos_libro["id"] = nuevo_id  # Añadimos el ID al diccionario validado.

        libros.append(datos_libro)  # Agregamos el nuevo libro a la lista.
        escribir_db(libros)  # Guardamos la lista actualizada en el archivo.

        # 5. Devolver el recurso recién creado (Serialización):
        #    Usamos `libro_schema.jsonify()` para convertir el diccionario del nuevo libro
        #    en una respuesta JSON, ahora incluyendo el ID que generamos.
        #    Devolvemos un código 201 Created para indicar que la operación fue exitosa.
        return libro_schema.jsonify(datos_libro), 201

# =================================================================
# 5. INICIO DE LA APLICACIÓN
# =================================================================
if __name__ == "__main__":
    app.run(debug=True)
